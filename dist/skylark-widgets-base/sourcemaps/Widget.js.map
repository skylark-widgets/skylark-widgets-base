{"version":3,"sources":["Widget.js"],"names":["define","skylark","langx","browser","datax","eventer","noder","files","geom","elmx","$","fx","plugins","HashMap","base","Widget","Plugin","inherit","klassName","_elmx","_construct","elm","options","isHtmlNode","this","_parse","overrided","_velm","_elm","_create","Object","defineProperty","value","state","_init","addonCategoryOptions","addons","constructor","categoryName","i","length","addonOption","isString","addonName","addonSetting","addonCtor","ctor","addon","optionsAttr","data","options1","JSON","parse","mixin","template","Error","self","widgetClass","addClass","on","e","args","_refresh","_startup","updates","mapping","events","attributs","properties","styles","setting","_addons","settings","category","undefined","clone","render","getEnclosing","selector","getEnclosed","children","ArrayList","show","hide","focus","ex","blur","enable","set","disable","aria","name","getEl","ariaTarget","_aria","get","setAttribute","attr","velm","ret","css","prop","throb","params","attach","target","position","before","after","append","detach","remove","meta","apply","arguments","addStatePropMethod","prototype","pluginName","register","widgetName"],"mappings":"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","file":"../Widget.js","sourcesContent":["define([\r\n  \"skylark-langx/skylark\",\r\n  \"skylark-langx/langx\",\r\n  \"skylark-domx-browser\",\r\n  \"skylark-domx-data\",\r\n  \"skylark-domx-eventer\",\r\n  \"skylark-domx-noder\",\r\n  \"skylark-domx-files\",\r\n  \"skylark-domx-geom\",\r\n  \"skylark-domx-velm\",\r\n  \"skylark-domx-query\",\r\n  \"skylark-domx-fx\",\r\n  \"skylark-domx-plugins\",\r\n  \"skylark-data-collection/HashMap\",\r\n  \"./base\"\r\n],function(skylark,langx,browser,datax,eventer,noder,files,geom,elmx,$,fx, plugins,HashMap,base){\r\n\r\n/*---------------------------------------------------------------------------------*/\r\n\r\n  var Widget = plugins.Plugin.inherit({\r\n    klassName: \"Widget\",\r\n\r\n    _elmx : elmx,\r\n\r\n    _construct : function(elm,options) {\r\n        if (langx.isHtmlNode(elm)) {\r\n          options = this._parse(elm,options);\r\n        } else {\r\n          options = elm;\r\n          elm = null;\r\n        }\r\n        this.overrided(elm,options);\r\n\r\n        if (!elm) {\r\n          this._velm = this._create();\r\n          this._elm = this._velm.elm();\r\n        } else {\r\n          this._velm = elmx(this._elm);\r\n        }\r\n        \r\n        Object.defineProperty(this,\"state\",{\r\n          value :this.options.state || new HashMap()\r\n        });\r\n\r\n        //this.state = this.options.state || new Map();\r\n        this._init();\r\n\r\n        var addonCategoryOptions = this.options.addons;\r\n        if (addonCategoryOptions) {\r\n          var widgetCtor = this.constructor,\r\n              addons = widgetCtor.addons;\r\n          for (var categoryName in addonCategoryOptions) {\r\n              for (var i =0;i < addonCategoryOptions[categoryName].length; i++ ) {\r\n                var addonOption = addonCategoryOptions[categoryName][i];\r\n                if (langx.isString(addonOption)) {\r\n                  var addonName = addonOption,\r\n                      addonSetting = addons[categoryName][addonName],\r\n                      addonCtor = addonSetting.ctor ? addonSetting.ctor : addonSetting;\r\n\r\n                  this.addon(addonCtor,addonSetting.options);\r\n\r\n                }\r\n\r\n              }\r\n          }\r\n\r\n\r\n        }\r\n\r\n\r\n     },\r\n\r\n    /**\r\n     * Parses widget options from attached element.\r\n     * This is a callback method called by constructor when attached element is specified.\r\n     * @method _parse\r\n     * @return {Object} options.\r\n     */\r\n    _parse : function(elm,options) {\r\n      var optionsAttr = datax.data(elm,\"options\");\r\n      if (optionsAttr) {\r\n         var options1 = JSON.parse(\"{\" + optionsAttr + \"}\");\r\n         options = langx.mixin(options1,options); \r\n      }\r\n      return options || {};\r\n    },\r\n\r\n\r\n    /**\r\n     * Create html element for this widget.\r\n     * This is a callback method called by constructor when attached element is not specified.\r\n     * @method _create\r\n     */\r\n    _create : function() {\r\n        var template = this.options.template;\r\n        if (template) {\r\n          return this._elmx(template);\r\n        } else {\r\n          throw new Error(\"The template is not existed in options!\");\r\n        }\r\n    },\r\n\r\n\r\n    /**\r\n     * Init widget.\r\n     * This is a callback method called by constructor.\r\n     * @method _init\r\n     */\r\n    _init : function() {\r\n      var self = this;\r\n      if (this.widgetClass) {\r\n        this._velm.addClass(this.widgetClass);\r\n      }\r\n      this.state.on(\"changed\",function(e,args) {\r\n        self._refresh(args.data);\r\n      });\r\n    },\r\n\r\n\r\n    /**\r\n     * Startup widget.\r\n     * This is a callback method called when widget element is added into dom.\r\n     * @method _post\r\n     */\r\n    _startup : function() {\r\n\r\n    },\r\n\r\n\r\n    /**\r\n     * Refresh widget.\r\n     * This is a callback method called when widget state is changed.\r\n     * @method _refresh\r\n     */\r\n    _refresh : function(updates) {\r\n      /*\r\n      var _ = this._,\r\n          model = _.model,\r\n          dom = _.dom,\r\n          props = {\r\n\r\n          };\r\n      updates = updates || {};\r\n      for (var attrName in updates){\r\n          var v = updates[attrName].value;\r\n          if (v && v.toCss) {\r\n              v.toCss(props);\r\n              updates[attrName].processed = true;\r\n          }\r\n\r\n      };\r\n\r\n      this.css(props);\r\n\r\n      if (updates[\"disabled\"]) {\r\n          var v = updates[\"disabled\"].value;\r\n          dom.aria('disabled', v);\r\n          self.classes.toggle('disabled', v);\r\n      }\r\n      */\r\n    },                \r\n\r\n    mapping : {\r\n      \"events\" : {\r\n  //       'mousedown .title':  'edit',\r\n  //       'click .button':     'save',\r\n  //       'click .open':       function(e) { ... }            \r\n      },\r\n\r\n      \"attributs\" : {\r\n\r\n      },\r\n\r\n      \"properties\" : {\r\n\r\n      },\r\n\r\n      \"styles\" : {\r\n\r\n      }\r\n    },\r\n\r\n    addon : function(ctor,setting) {\r\n      var categoryName = ctor.categoryName,\r\n          addonName = ctor.addonName;\r\n\r\n      this._addons = this.addons || {};\r\n      var category = this._addons[categoryName] = this._addons[categoryName] || {};\r\n      category[addonName] = new ctor(this,setting);\r\n      return this;\r\n    },\r\n\r\n    addons : function(categoryName,settings) {\r\n      this._addons = this.addons || {};\r\n      var category = this._addons[categoryName] = this._addons[categoryName] || {};\r\n\r\n      if (settings == undefined) {\r\n        return langx.clone(category || null);\r\n      } else {\r\n        langx.mixin(category,settings);\r\n      }\r\n    },\r\n\r\n\r\n    /**\r\n     * Returns a html element representing the widget.\r\n     *\r\n     * @method render\r\n     * @return {HtmlElement} HTML element representing the widget.\r\n     */\r\n    render: function() {\r\n      return this._elm;\r\n    },\r\n\r\n\r\n\r\n    /**\r\n     * Returns a parent widget  enclosing this widgets, or null if not exist.\r\n     *\r\n     * @method getEnclosing\r\n     * @return {Widget} The enclosing parent widget, or null if not exist.\r\n     */\r\n    getEnclosing : function(selector) {\r\n      return null;\r\n    },\r\n\r\n    /**\r\n     * Returns a widget collection with all enclosed child widgets.\r\n     *\r\n     * @method getEnclosed\r\n     * @return {List} Collection with all enclosed child widgets..\r\n     */\r\n    getEnclosed : function() {\r\n      var self = this;\r\n          children = new ArrayList();\r\n      return children;\r\n    },\r\n\r\n    /**\r\n     * Sets the visible state to true.\r\n     *\r\n     * @method show\r\n     * @return {Widget} Current widget instance.\r\n     */\r\n\r\n    show : function() {\r\n      this._velm.show();\r\n    },\r\n\r\n    /**\r\n     * Sets the visible state to false.\r\n     *\r\n     * @method hide\r\n     * @return {Widget} Current widget instance.\r\n     */\r\n    hide : function() {\r\n      this._velm.hide();\r\n    },\r\n\r\n    /**\r\n     * Focuses the current widget.\r\n     *\r\n     * @method focus\r\n     * @return {Widget} Current widget instance.\r\n     */\r\n    focus :function() {\r\n      try {\r\n        this._velm.focus();\r\n      } catch (ex) {\r\n        // Ignore IE error\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Blurs the current widget.\r\n     *\r\n     * @method blur\r\n     * @return {Widget} Current widget instance.\r\n     */\r\n    blur : function() {\r\n      this._velm.blur();\r\n\r\n      return this;\r\n    },\r\n\r\n    enable: function () {\r\n      this.state.set('disabled',false);\r\n      return this;\r\n    },\r\n\r\n    disable: function () {\r\n      this.state.set('disabled',true);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the specified aria property.\r\n     *\r\n     * @method aria\r\n     * @param {String} name Name of the aria property to set.\r\n     * @param {String} value Value of the aria property.\r\n     * @return {Widget} Current widget instance.\r\n     */\r\n    aria : function(name, value) {\r\n      const self = this, elm = self.getEl(self.ariaTarget);\r\n\r\n      if (typeof value === 'undefined') {\r\n        return self._aria[name];\r\n      }\r\n\r\n      self._aria[name] = value;\r\n\r\n      if (self.state.get('rendered')) {\r\n        elm.setAttribute(name === 'role' ? name : 'aria-' + name, value);\r\n      }\r\n\r\n      return self;\r\n    },\r\n\r\n    attr: function (name,value) {\r\n        var velm = this._velm,\r\n            ret = velm.attr(name,value);\r\n        return ret == velm ? this : ret;\r\n    },\r\n\r\n    css: function (name, value) {\r\n        var velm = this._velm,\r\n            ret = velm.css(name, value);\r\n        return ret == velm ? this : ret;\r\n    },\r\n\r\n    data: function (name, value) {\r\n        var velm = this._velm,\r\n            ret = velm.data(name,value);\r\n        return ret == velm ? this : ret;\r\n    },\r\n\r\n    prop: function (name,value) {\r\n        var velm = this._velm,\r\n            ret = velm.prop(name,value);\r\n        return ret == velm ? this : ret;\r\n    },\r\n\r\n    throb: function(params) {\r\n      return fx.throb(this._elm,params);\r\n    },\r\n\r\n\r\n    /**\r\n     *  Attach the current widget element to dom document.\r\n     *\r\n     * @method attach\r\n     * @return {Widget} This Widget.\r\n     */\r\n    attach : function(target,position){\r\n        var elm = target;\r\n        if (!position || position==\"child\") {\r\n            noder.append(elm,this._elm);\r\n        } else  if (position == \"before\") {\r\n            noder.before(elm,this._elm);\r\n        } else if (position == \"after\") {\r\n            noder.after(elm,this._elm);\r\n        }\r\n        this._startup();\r\n    },\r\n\r\n    /**\r\n     *  Detach the current widget element from dom document.\r\n     *\r\n     * @method html\r\n     * @return {HtmlElement} HTML element representing the widget.\r\n     */\r\n    detach : function() {\r\n      this._velm.remove();\r\n    }\r\n  });\r\n\r\n  Widget.inherit = function(meta) {\r\n    var ctor = plugins.Plugin.inherit.apply(this,arguments);\r\n\r\n    function addStatePropMethod(name) {\r\n        ctor.prototype[name] = function(value) {\r\n          if (value !== undefined) {\r\n            this.state.set(name,value);\r\n            return this;\r\n          } else {\r\n            return this.state.get(name);\r\n          }\r\n        };\r\n    }\r\n    if (meta.state) {\r\n      for (var name in meta.state) {\r\n          addStatePropMethod(name);\r\n      }\r\n    }\r\n\r\n    if (meta.pluginName) {\r\n      plugins.register(ctor,meta.pluginName);\r\n    }\r\n    return ctor;\r\n  };\r\n\r\n  Widget.register = function(ctor,widgetName) {\r\n    var meta = ctor.prototype,\r\n        pluginName = widgetName || meta.pluginName;\r\n\r\n    function addStatePropMethod(name) {\r\n        ctor.prototype[name] = function(value) {\r\n          if (value !== undefined) {\r\n            this.state.set(name,value);\r\n            return this;\r\n          } else {\r\n            return this.state.get(name);\r\n          }\r\n        };\r\n    }\r\n    if (meta.state) {\r\n      for (var name in meta.state) {\r\n          addStatePropMethod(name);\r\n      }\r\n    }\r\n\r\n    if (pluginName) {\r\n      plugins.register(ctor,pluginName);\r\n    }\r\n    return ctor;\r\n  };\r\n\r\n  return base.Widget = Widget;\r\n});\r\n"]}